const { ObjectId } = require("mongodb");
const { getDb } = require("../config/database"); // Assuming getDb returns the MongoDB database instance

// Helper function to get collections
const getCollections = () => {
  const db = getDb();
  return {
    orders: db.collection("orders"),
    users: db.collection("users"),
    courses: db.collection("courses"),
  };
};

// Order model
const OrderModel = {
  // Get all orders
  getAllOrders: async () => {
    const { orders } = getCollections();
    return await orders.find({}).toArray();
  },

  // Get order by ID
  getOrderById: async (id) => {
    const { orders } = getCollections();
     if (!ObjectId.isValid(id)) return null;
    return await orders.findOne({ _id: new ObjectId(id) });
  },

  // Get orders by user
  getOrdersByUser: async (userId) => {
    const { orders } = getCollections();
    const userObjectId = new ObjectId(userId);
    return await orders.find({ userId: userObjectId }).toArray();
  },

  // Create new order
  createOrder: async (orderData) => {
    const { orders } = getCollections();
    const userObjectId = new ObjectId(orderData.userId);
    // Assuming courseId is already an ObjectId or needs conversion
    const courseObjectId = new ObjectId(orderData.courseId);


    // Create new order document
    const newOrder = {
      // _id will be generated by MongoDB
      userId: userObjectId,
      courseId: courseObjectId, // Store as ObjectId
      items: orderData.items, // Assuming items might contain multiple courses/details
      amount: orderData.amount,
      paymentMethod: orderData.paymentMethod,
      status: orderData.status || "completed",
      createdAt: new Date(),
    };

    const result = await orders.insertOne(newOrder);
    // Fetch the inserted document to return it
    return await orders.findOne({_id: result.insertedId});
  },

  // Update order status
  updateOrderStatus: async (id, status) => {
    const { orders } = getCollections();
    const orderObjectId = new ObjectId(id);

    const result = await orders.updateOne(
      { _id: orderObjectId },
      { $set: { status: status, updatedAt: new Date() } } // Add updatedAt timestamp
    );

    if (result.matchedCount === 0) {
      throw new Error("Order not found");
    }

    return await orders.findOne({ _id: orderObjectId }); // Return updated order
  },

  // Get orders by course
  getOrdersByCourse: async (courseId) => {
    const { orders } = getCollections();
    const courseObjectId = new ObjectId(courseId);
    return await orders.find({ courseId: courseObjectId }).toArray();
  },

  // Get total revenue (from completed orders)
  getTotalRevenue: async () => {
    const { orders } = getCollections();
    const result = await orders.aggregate([
        { $match: { status: "completed" } },
        { $group: { _id: null, totalRevenue: { $sum: "$amount" } } }
    ]).toArray();

    return result.length > 0 ? result[0].totalRevenue : 0;
  },

  // Get revenue by month (last 6 months)
  getRevenueByMonth: async () => {
    const { orders } = getCollections();
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
    sixMonthsAgo.setDate(1); // Start from the beginning of the month
    sixMonthsAgo.setHours(0, 0, 0, 0); // Start from midnight

    const revenueData = await orders.aggregate([
        {
            $match: {
                status: "completed",
                createdAt: { $gte: sixMonthsAgo }
            }
        },
        {
            $group: {
                _id: { year: { $year: "$createdAt" }, month: { $month: "$createdAt" } },
                monthlyRevenue: { $sum: "$amount" }
            }
        },
        {
            $sort: { "_id.year": 1, "_id.month": 1 }
        }
    ]).toArray();

    // Format for chart - Create a map of all last 6 months first
    const monthMap = {};
    const now = new Date();
    for (let i = 5; i >= 0; i--) {
        const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const monthKey = `${year}-${month}`;
        monthMap[monthKey] = {
            month: date.toLocaleString('default', { month: 'short' }),
            year: year, // Keep year for potential multi-year charts
            revenue: 0
        };
    }

    // Populate with actual data
    revenueData.forEach(item => {
        const monthKey = `${item._id.year}-${item._id.month}`;
        if (monthMap[monthKey]) {
            monthMap[monthKey].revenue = item.monthlyRevenue;
        }
    });

    return Object.values(monthMap); // Return array of month objects
  },

  // Get recent orders with user and course details
  getRecentOrders: async (limit = 10) => {
    const { orders } = getCollections(); // No need for users/courses collections here if using $lookup

    const recentOrders = await orders.aggregate([
        { $sort: { createdAt: -1 } },
        { $limit: limit },
        {
            $lookup: {
                from: "users", // The name of the users collection
                localField: "userId",
                foreignField: "_id",
                as: "userDetails"
            }
        },
        {
            $lookup: {
                from: "courses", // The name of the courses collection
                localField: "courseId", // Assuming single courseId per order
                foreignField: "_id",
                as: "courseDetails"
            }
        },
        // Optional: Lookup multiple courses if items array exists
        // {
        //     $lookup: {
        //         from: "courses",
        //         localField: "items.courseId", // Adjust if items structure is different
        //         foreignField: "_id",
        //         as: "courseDetailsList"
        //     }
        // },
        {
            $project: { // Reshape the output
                _id: 1,
                userId: 1,
                courseId: 1, // Keep if needed
                amount: 1,
                status: 1,
                createdAt: 1,
                userName: { $arrayElemAt: ["$userDetails.name", 0] }, // Get name from the looked-up user
                userEmail: { $arrayElemAt: ["$userDetails.email", 0] }, // Example: get email too
                courseTitle: { $arrayElemAt: ["$courseDetails.title", 0] }, // Get title from the looked-up course
                // courseTitles: "$courseDetailsList.title" // Example if multiple courses looked up
            }
        }
    ]).toArray();

    // Add default values if lookup failed (user/course deleted)
     return recentOrders.map(order => ({
         ...order,
         userName: order.userName || "Unknown User",
         courseTitle: order.courseTitle || "Unknown Course"
     }));
  },
};

module.exports = OrderModel;
